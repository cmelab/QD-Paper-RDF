import os
import sys
from math import sqrt
from skimage.io import imread
from skimage.feature import blob_dog, blob_log, blob_doh
from skimage.color import rgb2gray
import base64
import pathlib
import json
from PIL import Image
from argparse import ArgumentParser
import matplotlib.pyplot as plt


def main(target_dir_or_file, max_sigma=5, thresh=0.1, pick_index=None, show=True, save=False):
    '''This script uses blob detection features of skimage (with parameters set by the user) to
    automatically generate annotations for quantum dots in the COCO format. It can operate on
    single image files, or recursively operate on directories of images.'''
    if os.path.isdir(target_dir_or_file):
        process_image_dir(target_dir_or_file, max_sigma, thresh, pick_index, show, save)
    elif os.path.isfile(target_dir_or_file):
        process_single_file(target_dir_or_file, max_sigma, thresh, pick_index, show, save)
    else:
        print("invalid image_dir or filepath, please check that this path exists or use the --help flag for usage information.")

def to_single_coco_label(x,y,r):
    '''
    Takes in circular label information and transforms it into a COCO label in polygon format with a bounding box.

    :int x: x-coordinate of circle's center
    :int y: y-coordinate of circle's center
    :int r: radius of circle

    Returns dict object containing a single label in COCO format.
    '''
    x1, y1 = x-r, y+r # top left
    x2, y2 = x+r, y+r # top right
    x3, y3 = x-r, y-r # bottom left
    x4, y4 = x+r, y-r # bottom right
    return {
      "segmentation": [[x1,y1,x2,y2,x3,y3,x4,y4]], # list of points in polygon (just a rectangle in this case)
      "bbox": [x1,y1,x4,y4], # bounding box in 
      "group_id": "null",
      "shape_type": "polygon",
      "flags": {}
    }

def to_coco_annotations_file(filepath, labels):
    '''
    Takes in a single filepath and a list of all labels for it, and
    generates a full COCO annotations file for it.

    :str filepath: filepath to raw image
    :list labels: list of labels (each label generated by the `to_single_coco_label()` function)
    '''
    with open(filepath,'rb') as f:
        img_data = base64.b64encode(f.read()).decode('utf-8')
    image = Image.open(filepath)
    img_width, img_height = image.size

    return {
        "version": "4.6.0",
        "flags": {},
        "annotations": labels,
        "imagePath": filepath,
        "imageData": img_data,
        "imageWidth": img_width,
        "imageHeight": img_height
    }

def process_image_dir(image_dir: str, max_sigma: float, thresh: float, pick_index: int, show: bool, save: bool):
    for curr_dir, next_dirs, files in os.walk(image_dir):
        for f in files:
            if not f.endswith('.tif'):
                continue

            filepath = os.path.join(curr_dir, f)
            image = image_gray = imread(filepath, as_gray=True)

            blobs_log = blob_log(image_gray, max_sigma=max_sigma, num_sigma=10, threshold=thresh)

            # Compute radii in the 3rd column.
            blobs_log[:, 2] = blobs_log[:, 2] * sqrt(2)

            blobs_dog = blob_dog(image_gray, max_sigma=max_sigma, threshold=thresh)
            blobs_dog[:, 2] = blobs_dog[:, 2] * sqrt(2)

            blobs_doh = blob_doh(image_gray, max_sigma=max_sigma, threshold=thresh)

            blobs_list = [blobs_log, blobs_dog, blobs_doh]
            colors = ['yellow', 'lime', 'red']
            titles = ['Laplacian of Gaussian', 'Difference of Gaussian',
                    'Determinant of Hessian']
            sequence = zip(blobs_list, colors, titles)

            fig, axes = plt.subplots(1, 3, figsize=(9, 3), sharex=True, sharey=True)
            ax = axes.ravel()
            labels = []
            for idx, (blobs, color, title) in enumerate(sequence):
                ax[idx].set_title(title)
                ax[idx].imshow(image)
                for blob in blobs:
                    y, x, r = blob
                    c = plt.Circle((x, y), r, color=color, linewidth=2, fill=False)
                    
                    if idx == pick_index:
                        label = to_single_coco_label(x, y, r)
                        labels.append(label)
                    
                    ax[idx].add_patch(c)
                ax[idx].set_axis_off()

            if show:
                plt.tight_layout()
                plt.show()
                sys.exit(0)
            elif save:
                out = to_coco_annotations_file(filepath, labels)
                p = pathlib.Path(filepath)
                output_path = os.path.join(curr_dir, p.stem + '.json')
                with open(output_path, 'w') as f:
                    json.dump(out, f)
                print(f"Saved to {output_path}")

def process_single_file(filepath: str, max_sigma: float, thresh: float, pick_index: int, show: bool, save: bool):
    image = image_gray = imread(filepath, as_gray=True)

    blobs_log = blob_log(image_gray, max_sigma=max_sigma, num_sigma=10, threshold=thresh)

    # Compute radii in the 3rd column.
    blobs_log[:, 2] = blobs_log[:, 2] * sqrt(2)

    blobs_dog = blob_dog(image_gray, max_sigma=max_sigma, threshold=thresh)
    blobs_dog[:, 2] = blobs_dog[:, 2] * sqrt(2)

    blobs_doh = blob_doh(image_gray, max_sigma=max_sigma, threshold=thresh)

    blobs_list = [blobs_log, blobs_dog, blobs_doh]
    colors = ['yellow', 'lime', 'red']
    titles = ['Laplacian of Gaussian', 'Difference of Gaussian',
            'Determinant of Hessian']
    sequence = zip(blobs_list, colors, titles)

    fig, axes = plt.subplots(1, 3, figsize=(9, 3), sharex=True, sharey=True)
    ax = axes.ravel()
    labels = []
    for idx, (blobs, color, title) in enumerate(sequence):
        ax[idx].set_title(title)
        ax[idx].imshow(image)
        for blob in blobs:
            y, x, r = blob
            c = plt.Circle((x, y), r, color=color, linewidth=2, fill=False)
            
            if idx == pick_index:
                label = to_single_coco_label(x, y, r)
                labels.append(label)
            
            ax[idx].add_patch(c)
        ax[idx].set_axis_off()

    # show preview of algos with given parameters on example image
    if show:
        plt.tight_layout()
        plt.show()
        sys.exit(0)

    # save 
    elif save:
        out = to_coco_annotations_file(filepath, labels)
        p = pathlib.Path(filepath)
        curr_dir = os.path.dirname(filepath)
        output_path = os.path.join(curr_dir, p.stem + '.json')
        with open(output_path, 'w') as f:
            json.dump(out, f)
        print(f"Saved to {output_path}")

if __name__ == '__main__':
    parser = ArgumentParser("autolabel-parser", description="""This script uses blob detection features of skimage (with parameters set by the user) to
    automatically generate annotations for quantum dots in the COCO format. It can operate on
    single image files, or recursively operate on directories of images.""")
    parser.add_argument('--target', type=str, required=True, help='image directory or filename')
    parser.add_argument('--max_sigma', type=int, default=5, required=False, help='The maximum standard deviation for Gaussian kernel. Keep this high to detect larger blobs. Range of 1-20 recommended.')
    parser.add_argument('--threshold', type=float, default=0.1, required=False, help='The absolute lower bound for scale space maxima. Local maxima smaller than threshold are ignored. Reduce this to detect blobs with lower intensities. Range 0.0-0.2 recommended.')
    parser.add_argument('--show', action="store_true", help="flag to show preview of all 3 algorithms with the given settings on an example image.")
    parser.add_argument('--save', action="store_true", help="flag to use the specified algorithm (LoG, DoG, DoH) to label all images and save labels as JSON files.")
    parser.add_argument('--log', action="store_true", help="Laplacian of Gaussian (leftmost image in --show mode")
    parser.add_argument('--dog', action="store_true", help="Difference of Gaussian (middle image in --show mode)")
    parser.add_argument('--doh', action="store_true", help="Determinant of Hessian (rightmost image in --show mode)")
    args = parser.parse_args()
    print(f"Autolabel parameters: {args}")
    
    # validate algo if --save specified
    pick_index = None
    if args.save:
        if args.log:
            pick_index = 0
        elif args.dog:
            pick_index = 1
        elif args.doh:
            pick_index = 2
        else:
            print("You must choose an algorithm (--log, --dog, or --doh) to save annotations. Use --help for more details.")
            sys.exit(0)
    
    # execute script with these params
    main(args.target, args.max_sigma, args.threshold, pick_index, args.show, args.save)